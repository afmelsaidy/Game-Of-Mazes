var GameScene = Class.create(Scene, {
	randomEmpty: [],
	dataPool: null,
	pool: [],
	pool2: [],
	taken: [],
	ammo: 10,
	score: 1000,


	initialize: function() {
		this.dataPool = new ObjectPool();
		this.pool = this.dataPool.pool;
		this.pool2 = this.dataPool.pool2;
		Scene.apply(this);

		$('.dashboard').show();
		$('#ammo').text(this.ammo);
		$('#score').text(this.score);

		// GameScene instance variable
		var GS = this;

		setInterval(function() {
			GS.score -= 1;
		}, 1000, GS);

		// TO-DO change Game class
		var game = Game.instance;

		// Set the inputs key needed
		game.keybind(32, 'space');
		game.keybind(16, 'shift');

		// Key listener for the (P)
		document.addEventListener('keyup', function(e) {
			// if P is pressed & the global value of game running is false
			// then the game was paused & need to be resumed
			if (e.keyCode == 80 && !gameIsRunning) {
				gameIsRunning = true;
				game.resume();
				console.info("GAME RESUMED");
			} else if (e.keyCode == 80 && gameIsRunning) {
				// If P is pressed & the game is Running then we need to pause it
				gameIsRunning = false;
				game.pause();
				console.info("GAME PAUSED");
			}
		});

		// Maze Class
		var maze = new Maze(20, 20);
		// Get the array generated by maze (ones & zeros)
		this.mazeArray = maze.getMazeArray();

		// Generate a 2D map objects for the map
		// this.mapObjects = create2dArray(mazeArray.length);
		this.mapObjects = this.generatingMapObjects(this.mazeArray, this.coins);


		// Add the end point
		var endP = new EndPoint();
		endP.moveTo((i - 2) * 16, (j - 2) * 16);

		this.addChild(endP);

		// Add the hero
		var AryaStark = new Hero();
		AryaStark.moveTo(16, 16);

		this.addEventListener('enterframe', function() {
			$('#score').text(this.score);

			var heroCoinHits = AryaStark.intersect(Coin);
			if (heroCoinHits.length) {
				// Remove the coin
				this.removeChild(heroCoinHits[0]);
				this.returnObjPool(this.pool2.pop());
				this.score += 10;
				Game.instance.assets['assets/Pickup_Coin.wav'].play();
			}

			var heroAmmoHits = AryaStark.intersect(Ammo);
			if (heroAmmoHits.length) {
				// Remove the coin
				this.removeChild(heroAmmoHits[0]);
				this.returnObjPool(heroAmmoHits[0]);
				this.ammo += 5;
				$('#ammo').text(this.ammo);
				Game.instance.assets['assets/Pickup_Coin2.wav'].play();
			}

			// Bullet hit BombA Or BombB Or Orc Or Oger
			this.hitTrue(BombA, this, AryaStark);
			this.hitTrue(BombB, this, AryaStark);
			this.hitTrue(Orc, this, AryaStark);
			this.hitTrue(Oger, this, AryaStark);
			this.hitTrue(MudWall, this, AryaStark);



			// Bullet intersection with the wall make it disappear
			var bulletStoneWall = Projectile.intersectStrict(StoneWall);
			if (bulletStoneWall.length) {
				this.removeChild(bulletStoneWall[0][0]);
			}


			if (game.input.space && this.ammo > 0) {
				game.input.space = false;
				this.addChild(this.fire(AryaStark));
				$('#ammo').text(this.ammo);
				Game.instance.assets['assets/Laser_Shoot.wav'].play();
			}

			if (AryaStark.isMoving && AryaStark.isAlive) {

				AryaStark.moveBy(AryaStark.vx, AryaStark.vy);

				AryaStark.frame = AryaStark.animationArray[(AryaStark.frame + 1) % 3];

				if ((AryaStark.vx && (AryaStark.x - 16) % 16 === 0) || (AryaStark.vy && (AryaStark.y - 16) % 16 === 0)) {
					AryaStark.isMoving = false;
				}

			} else if (AryaStark.isAlive) {
				AryaStark.vx = AryaStark.vy = 0;

				var currentDirection = AryaStark.direction;

				if (game.input.left) {
					AryaStark.turnLeft();
					// If user is hitting shift key then don't move just turn around !
					AryaStark.vx = game.input.shift ? 0 : -4;
				} else if (game.input.right) {
					AryaStark.turnRight();
					// If user is hitting shift key then don't move just turn around !
					AryaStark.vx = game.input.shift ? 0 : 4;
				} else if (game.input.up) {
					AryaStark.turnUp();
					// If user is hitting shift key then don't move just turn around !
					AryaStark.vy = game.input.shift ? 0 : -4;
				} else if (game.input.down) {
					AryaStark.turnDown();
					// If user is hitting shift key then don't move just turn around !
					AryaStark.vy = game.input.shift ? 0 : 4;
				}

				var newDirection = AryaStark.direction;

				if ((AryaStark.vx || AryaStark.vy) && newDirection == currentDirection) {
					var x = AryaStark.x + (AryaStark.vx ? AryaStark.vx / Math.abs(AryaStark.vx) * 16 : 0) + 12;
					var y = AryaStark.y + (AryaStark.vy ? AryaStark.vy / Math.abs(AryaStark.vy) * 16 : 0) + 12;
					if (0 <= x && x < 41 * 16 && 0 <= y && y < 41 * 16 && !this.isNotAllowed(x, y)) {
						AryaStark.isMoving = true;
						arguments.callee.call(this);
					}
				}
			}

			var anim = new Animation();
			if (Math.floor(Math.random() * 10000) > 9000) {
				if (this.pool.length > 0) {
					var rand = Math.floor(Math.random() * this.randomEmpty.length);
					var temp = this.randomEmpty[rand];
					var xyz = this.getObjPool();
					xyz.moveTo(temp[0] * 16, temp[1] * 16);
					anim.moveTo(temp[0] * 16, temp[1] * 16);
					this.addChild(xyz);
					this.addChild(anim);
					setTimeout(function() {
						GS.removeChild(anim);
					}, 500, anim, GS);
					this.addChild(anim);
				}
			}
		});

		this.addChild(AryaStark);


		AryaStark.addEventListener('enterframe', function() {
			// Handle if Stark hit a bomb A or B
			hitsA = this.intersect(BombA);
			hitsB = this.intersect(BombB);
			hitsMonA = this.intersect(Oger);
			hitsMonB = this.intersect(Orc);
			hitsEnd = this.intersect(EndPoint);
			if (hitsA.length) GS.AryaStarkHitBomb(this, GS, 'A', hitsA);
			if (hitsB.length) GS.AryaStarkHitBomb(this, GS, 'B', hitsB);
			if (hitsMonA.length) GS.Dead(hitsMonA, GS, 'C', this);
			if (hitsMonB.length) GS.Dead(hitsMonB, GS, 'C', this);
			if (hitsEnd.length) GS.Dead(hitsEnd, GS, 'E', this);
		});
	},
	getMapObjects: function() {
		return this.mapObjects;
	},

	generatingMapObjects: function(mazeArray, coins) {

		// Create an empty array of maps objects
		var mapObjects = create2dArray(mazeArray.length);
		var xAxis = [-1, 0, 1, 0],
			yAxis = [0, 1, 0, -1];
		/*	
			Directions : North=0
						 East =1
						 South =2
						 West =3
		*/
		for (i = 0; i < mazeArray.length; i++) {
			for (j = 0; j < mazeArray.length; j++) {
				if (mazeArray[i][j] === 1 && !isBoundaries(i, j, mazeArray.length)) {
					// If this block is a restricted block & Not a boundary
					mapObjects[i][j] = Math.random() > 0.9 ? new MudWall() : new StoneWall();
				} else if (mazeArray[i][j] === 1) {
					// If this block is restricted & A boundary
					mapObjects[i][j] = new BoundaryWall();
				} else {
					// If a normal road
					mapObjects[i][j] = new Road();
					if (this.randomizePick() > 0.5) {
						this.randomEmpty.push([i, j]);
					}
				}

				// SET THE LOCATION OF THE BLOCK IN SPIRIETS
				mapObjects[i][j].moveTo(i * 16, j * 16);

				this.addChild(mapObjects[i][j]);
				if (this.randomizePick() > 0.95 && this.pool.length > 0 && mazeArray[i][j] === 0) {
					if (i > 2 && j > 2) {
						var obstacle = this.getObjPool();
						obstacle.moveTo(i * 16, j * 16);
						if (obstacle.type == 'Oger') {
							/*
							while(true){
								var direction=Math.floor((Math.random() * 4));
								var distance=0;
								while(!this.isNotAllowed(i+xAxis[direction],j+yAxis[direction])){
									distance++;

								}
								console.log(distance);
								if(distance>0){
									console.log(distance);
									obstacle.direction=direction;
									obstacle.distance=distance;
									break;
								}
							}
							*/

						}

						this.addChild(obstacle);
					}
				}
			}
		}
		return mapObjects;
	},

	randomizePick: function() {
		var rand = Math.random();
		return rand;
	},

	randomizeReturn: function(arrLength) {
		var rand = Math.random();
		return rand * arrLength;
	},

	getObjPool: function() {
		var x = this.pool.pop();
		this.taken.push(x);
		return x;
	},

	returnObjPool: function(x) {
		this.pool.splice(this.randomizeReturn(this.pool.length), 0, x);
	},

	isNotAllowed: function(x, y) {
		return this.mazeArray[parseInt(x / 16, 10)][parseInt(y / 16, 10)];
	},
	AryaStarkHitBomb: function(AryaStark, GS, bombType, hits) {
		if (hits.length) {
			// If the bomb type is B , we need to hold it some time before the explosion
			if (bombType === 'B') {
				// setTimeout(GS.BombExplode(hits, GS), BombB.waitTime);
				setTimeout(GS.Dead, 500, hits, GS, 'B', AryaStark);
			} else {
				GS.Dead(hits, GS, 'A', AryaStark);
			}
		}
	},
	hitTrue: function(targetClass, GS, AryaStark) {
		var targetClassHits = Projectile.intersectStrict(targetClass);

		if (targetClassHits.length) {
			// Get the axises of the Bomb to use it later
			var ax_x = targetClassHits[0][1].x,
				ax_y = targetClassHits[0][1].y;
			// Create a new Road block to replace it
			var road = new Road();
			// Move the road block to the position of the mud wall to replace it
			road.moveTo(ax_x, ax_y);
			// Reset the value of this block in the array to make it a free space to move in
			if (GS.mapObjects[ax_x / 16] && GS.mapObjects[ax_x / 16][ax_y / 16]) {
				GS.mapObjects[ax_x / 16][ax_y / 16] = road;
			}
			if (GS.mazeArray[ax_x / 16] && GS.mazeArray[ax_x / 16][ax_y / 16]) {
				GS.mazeArray[ax_x / 16][ax_y / 16] = 0;
			}
			// Remove the mud wall from scene
			GS.removeChild(targetClassHits[0][1]);
			GS.returnObjPool(targetClassHits[0][1]);
			Game.instance.assets['assets/Explosion.wav'].play();
			// Remove AryaStaro & added it again to be on top of the ground
			GS.removeChild(AryaStark);
			// Add the road to the scene
			GS.addChild(road);
			// Then re Add Area to be on top of the ground
			GS.addChild(AryaStark);
			// Remove the bullet from the scene
			GS.removeChild(targetClassHits[0][0]);
		}

	},

	Dead: function(hits, GS, dType, AryaStark) {
		var explosion = new Animation();
		explosion.moveTo(hits[0].x, hits[0].y);

		var explosionHit = false;

		if (dType === 'B' && AryaStark.isAlive === true) {
			explosionHit = AryaStark.intersect(hits[0]);
			// if (explosionHit) Game.instance.stop();
			AryaStark.isAlive = !explosionHit;
		} else {
			explosionHit = true;
			// We don't stop the game because we want to wait until the explosion animation finish
			AryaStark.isAlive = false;
			// Game.instance.stop();		}
			if (dType !== 'E') {
				GS.addChild(explosion);
				GS.removeChild(hits[0]);
				Game.instance.assets['assets/Explosion8.wav'].play();
				setTimeout(function() {
					GS.removeChild(explosion);
					this.toEndScene(0);
					if (explosionHit) {
						//////////////////////////
						// YOU DIED OOOOPS ! ////
						//////////////////////////
						// Game.instance.stop();
					}
				}, 1000, explosion, GS);
			} else setTimeout(function() {
				this.toEndScene(1);
			}, 100, explosion, GS);
		}
	},

	fire: function(AryaStark) {
		this.ammo--;
		var bullet = new Projectile();
		bullet.moveTo(AryaStark.x, AryaStark.y);

		switch (AryaStark.direction) {
			case 0:
				bullet.tl.moveBy(0, 41 * 16, 100);
				break;
			case 1:
				bullet.tl.moveBy(0, -41 * 16, 100);
				break;
			case 2:
				bullet.tl.moveBy(-41 * 16, 0, 100);
				break;
			case 3:
				bullet.tl.moveBy(41 * 16, 0, 100);
				break;
		}
		return bullet;
	}
});


// Static Functions
isBoundaries = function(i, j, length) {
	// Check if it's a boundary in the map
	return (i === 0 || j === 0 || j === length - 1 || i === length - 1);
};

create2dArray = function(height, width, value) {
	if (!value) value = 0;
	if (height && !width) width = height;
	var arr = [];
	for (i = 0; i < height; i++) arr[i] = [];
	for (i = 0; i < height; i++)
		for (j = 0; j < width; j++)
			arr[i][j] = value;
	return arr;
};

var sleep = function(milliseconds) {
	var start = new Date().getTime();
	for (var i = 0; i < 1e7; i++) {
		if ((new Date().getTime() - start) > milliseconds) {
			break;
		}
	}
};

toEndScene = function(status) {
	/*
		end the game status == 0 lose , status ==1 win
	*/
	Game.instance.replaceScene(new EndScene(status));
};